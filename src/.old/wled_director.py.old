import yaml, httpx, random, copy, colorsys, re
from datetime import datetime, timedelta
from concurrent.futures import ThreadPoolExecutor

from yamlinclude import YamlIncludeConstructor
YamlIncludeConstructor.add_to_loader_class(loader_class=yaml.FullLoader, base_dir='')

import logging, sys
import logging.handlers

class logColorCodes:
    grey = "\x1b[38;21m"
    green = "\x1b[1;32m"
    yellow = "\x1b[33;21m"
    red = "\x1b[31;21m"
    bold_red = "\x1b[31;1m"
    blue = "\x1b[1;34m"
    light_blue = "\x1b[1;36m"
    purple = "\x1b[1;35m"
    reset = "\x1b[0m"


def fmt_filter(self, record):
        record.levelname = '<%s>' % record.levelname
        record.funcName = '%s()' % record.funcName
        return True

log_stream_formatter = logging.Formatter( f'{logColorCodes.blue}[%(asctime)s] {logColorCodes.light_blue}%(levelname)-8s {logColorCodes.purple}%(filename)s{logColorCodes.reset} {logColorCodes.green}%(name)s{logColorCodes.reset}.{logColorCodes.yellow}%(funcName)s{logColorCodes.reset} %(message)s' ) #, "%Y-%m-%d %H:%M:%S" )
log_file_formatter = logging.Formatter( f'[%(asctime)s] %(levelname)-8s %(filename)s %(name)s.%(funcName)s %(message)s' ) #, "%Y-%m-%d %H:%M:%S" )

log = logging.getLogger('WLED')
log.setLevel(logging.DEBUG)

handler = logging.handlers.SysLogHandler(address = ('graylog.knet',1550))
handler.setLevel( logging.WARNING )
handler.setFormatter( log_file_formatter )
log.addHandler(handler)

handler = logging.StreamHandler(sys.stdout)
handler.setLevel( logging.DEBUG )
handler.setFormatter( log_stream_formatter )
log.addHandler(handler)

log.addFilter( fmt_filter )

def log_handle_exception( exc_type, exc_value, exc_traceback ) -> None:
    log.error( "Uncaught exception", exc_info=(exc_type, exc_value, exc_traceback) )

sys.excepthook = log_handle_exception



ENV = "vscode"

if ENV == "vscode":
    log = logging.Logger( "WLED" )

def debug( msg ):
    if ENV == "vscode":
        print( msg )

class WLED_Director( ):

    _json_strip = ['udpn', 'ps', 'pl', 'nl', 'on', 'bri', 'transition', 'lor', 'mainseg' ]

    _palettes = ['Default', '* Random Cycle', '* Color 1', '* Colors 1&2', '* Color Gradient', '* Colors Only', 'Party', 'Cloud', 
                'Lava', 'Ocean', 'Forest', 'Rainbow', 'Rainbow Bands', 'Sunset', 'Rivendell', 'Breeze', 'Red & Blue', 'Yellowout', 
                'Analogous', 'Splash', 'Pastel', 'Sunset 2', 'Beech', 'Vintage', 'Departure', 'Landscape', 'Beach', 'Sherbet', 'Hult', 
                'Hult 64', 'Drywet', 'Jul', 'Grintage', 'Rewhi', 'Tertiary', 'Fire', 'Icefire', 'Cyane', 'Light Pink', 'Autumn', 
                'Magenta', 'Magred', 'Yelmag', 'Yelblu', 'Orange & Teal', 'Tiamat', 'April Night', 'Orangery', 'C9', 'Sakura', 'Aurora', 
                'Atlantica', 'C9 2', 'C9 New', 'Temperature', 'Aurora 2', 'Retro Clown', 'Candy', 'Toxy Reaf', 'Fairy Reaf', 'Semi Blue', 
                'Pink Candy', 'Red Reaf', 'Aqua Flash', 'Yelblu Hot', 'Lite Light', 'Red Flash', 'Blink Red', 'Red Shift', 'Red Tide', 'Candy2'
    ]

    _effects = ['Solid', 'Blink', 'Breathe', 'Wipe', 'Wipe Random', 'Random Colors', 'Sweep', 'Dynamic', 'Colorloop', 'Rainbow', 'Scan', 
            'Scan Dual', 'Fade', 'Theater', 'Theater Rainbow', 'Running', 'Saw', 'Twinkle', 'Dissolve', 'Dissolve Rnd', 'Sparkle', 
            'Sparkle Dark', 'Sparkle+', 'Strobe', 'Strobe Rainbow', 'Strobe Mega', 'Blink Rainbow', 'Android', 'Chase', 'Chase Random', 
            'Chase Rainbow', 'Chase Flash', 'Chase Flash Rnd', 'Rainbow Runner', 'Colorful', 'Traffic Light', 'Sweep Random', 'Chase 2', 
            'Aurora', 'Stream', 'Scanner', 'Lighthouse', 'Fireworks', 'Rain', 'Tetrix', 'Fire Flicker', 'Gradient', 'Loading', 'Police', 
            'Fairy', 'Two Dots', 'Fairytwinkle', 'Running Dual', 'Halloween', 'Chase 3', 'Tri Wipe', 'Tri Fade', 'Lightning', 'ICU', 
            'Multi Comet', 'Scanner Dual', 'Stream 2', 'Oscillate', 'Pride 2015', 'Juggle', 'Palette', 'Fire 2012', 'Colorwaves', 'Bpm', 
            'Fill Noise', 'Noise 1', 'Noise 2', 'Noise 3', 'Noise 4', 'Colortwinkles', 'Lake', 'Meteor', 'Meteor Smooth', 'Railway', 
            'Ripple', 'Twinklefox', 'Twinklecat', 'Halloween Eyes', 'Solid Pattern', 'Solid Pattern Tri', 'Spots', 'Spots Fade', 'Glitter', 
            'Candle', 'Fireworks Starburst', 'Fireworks 1D', 'Bouncing Balls', 'Sinelon', 'Sinelon Dual', 'Sinelon Rainbow', 'Popcorn', 'Drip', 
            'Plasma', 'Percent', 'Ripple Rainbow', 'Heartbeat', 'Pacifica', 'Candle Multi', 'Solid Glitter', 'Sunrise', 'Phased', 'Twinkleup', 
            'Noise Pal', 'Sine', 'Phased Noise', 'Flow', 'Chunchun', 'Dancing Shadows', 'Washing Machine', 'Candy Cane', 'Blends', 'TV Simulator', 
            'Dynamic Smooth'
    ]

    # @pyscript_compile
    def pull_config( self ):
        with open( "wled-holiday.yaml", 'r' ) as file:
            self.config = yaml.load( file, yaml.FullLoader )

    # @pyscript_compile
    def wled_post( self, host, data ):
        try:
            r = httpx.post( url=f"{host}/json/state", json=data )

            if r.status_code == 200:
                return
                #debug( f"{host=}, {r.json()}" )
        except BaseException as e:
            log.error( f"wled_post( {host} ) - {e}")

        

    # @pyscript_compile
    def wled_get( self, host, path="/json/state" ):
        r = httpx.get( url=f"{host}{path}" )

        if r.status_code == 200:
            return r.json()

        return None
    
    ## send data to all of the wled instances TODO: make this asynchronuous.
    # @pyscript_compile
    def update_lights( self ):
        req_hosts = []
        req_data = []

        for r, hosts in self.config['hosts'].items():
            for hn, h in hosts.items():

                if hn == "data":
                    continue

                if "enabled" not in h or not h['enabled']:
                    continue

                # adjust segments to light ( trim/duplicate )
                wled_segs = h['segments']
                data = copy.deepcopy( self.wled_data[r] )
                data_segs = len( data['seg'] )

                if wled_segs > data_segs:
                    for i in range( data_segs, wled_segs ):
                        data['seg'].append( data['seg'][i%data_segs])
                elif wled_segs < data_segs:
                    for i in range( wled_segs, data_segs ):
                        data['seg'].pop(wled_segs)

                debug( f"update_lights({hn}) - {data}")
                req_hosts.append( h['hostname'])
                req_data.append( data )


        with ThreadPoolExecutor(max_workers=7) as pool:
            pool.map(self.wled_post,req_hosts, req_data)
    
    def hsv_to_rgb( self, h:int, s:int, v:int ):
        hf = h/255
        sf = s/255
        vf = v/255

        ( rf, gf, bf ) = colorsys.hsv_to_rgb( hf, sf, vf )

        return [ int(rf*255), int(gf*255), int(bf*255) ]


    def color_random_hue( self ) -> list:
        return self.hsv_to_rgb( random.randrange(0,256), 255, 255 )
    
    def color_random_list_single( self, list:str, count:int = 1 ) -> list:
        if list not in self.config['lists']['colors']:
            log.error( f"{list} not in ")
        if count == 1:
            return [0,0,0]
        else:
            ret = []

            for i in range( count ):
                ret.append( [0,0,0] )
    
    
    def parse_effect( self, name:str, role:str ):

        if name not in self.config['effects']:
            return None
        
        effect = copy.deepcopy( self.config['effects'][name] )

        for i_seg in range(len(effect['seg'])):
            for k, v in effect['seg'][i_seg].items():
                if isinstance( v, str ):
                    if v.find( "$new_rand" ) == 0:
                        sub = v[10:-1]
                        ## TODO ==== finish this!!!!


            if 'fx' in effect['seg'][i_seg]:
                fx = effect['seg'][i_seg]['fx']

                if isinstance( fx, str ):
                    if fx in self._effects:
                        effect['seg'][i_seg]['fx'] = self._effects.index( fx )
                    else:
                        log.error( f"{fx} not in self._effects!" )
                        effect['seg'][i_seg]['fx'] = 0
        
        return effect
    
    def new_rand( self, key:str, first:int, second:int = 0 ) -> int:
        if second:
            rand = random.randrange(first,second)
        else:
            rand = random.randrange( first )

        self.last_random[key] = rand
        return rand
    
    ## one shot rand ( reset every time )
    def last_rand( self, key:str, first:int, second:int = 0 ):
        if key in self.last_random:
            return self.last_random[key]
        
        return self.new_rand( key, first, second )


    def parse_scheme( self, name:str ):

        if name not in self.config['schemes']:
            return None
        
        scheme = copy.deepcopy( self.config['schemes'][name] )

        #debug( f"PRE: {scheme=}")

        for i_seg in range(len(scheme['seg'])):
            if 'pal' in scheme['seg'][i_seg]:
                pal = scheme['seg'][i_seg]['pal']

                if isinstance( pal, str ):
                    if pal in self._palettes:
                        scheme['seg'][i_seg]['pal'] = self._palettes.index( pal )
                    else:
                        log.error( f"{pal} not in self._palettes!" )
                        scheme['seg'][i_seg]['pal'] = 0

            if 'col' in scheme['seg'][i_seg]:
                for i_col in range(len(scheme['seg'][i_seg]['col'])):
                    # handle string values ( pull from libraries/handle active controls )
                    col = scheme['seg'][i_seg]['col'][i_col]
                    if isinstance( col, str ):
                        if col[0] == '$':
                            if col[1:] == "random_hue":
                                scheme['seg'][i_seg]['col'][i_col] = self.color_random_hue()
                                continue

                            elif col.find( "$random_list" ) == 0:
                                #debug( "col: random_list" )
                                l_name = col.strip()[13:-1]
                                #debug( f"{l_name=}" )

                                if l_name in self.config['lists']['colors']:
                                    n_col = random.choice( self.config['lists']['colors'][l_name] )

                                    if isinstance( n_col, list ):
                                        scheme['seg'][i_seg]['col'][i_col] = n_col
                                        continue

                                    col = n_col
                        
                        if col in self.config['colors']:
                            scheme['seg'][i_seg]['col'][i_col] = self.config['colors'][col]
                        else:
                            scheme['seg'][i_seg]['col'][i_col] = [0,0,0]
                            log.error( f"parse_scheme: {col} not in config.colors!" )

        #debug( f"POST: {scheme=}" )
                            
        return scheme
    
    def check_update( self ):
        if self.ha_pull_config:
            self.pull_config()
            self.ha_pull_config = False

        if self.show == "off":
            return

        if self.ha_pick_show:
            self.time_pick_show = datetime.now()
            self.ha_pick_show = False

        if self.time_pick_show <= datetime.now():
            for r in self.wled_data:
                self.init_wled_data(r)

            if self.pick_show():
                self.time_pick_show = datetime.now() + self.show_duration
                
                self.update_lights()
            else:
                log.warning( "pick_show() returned None, retry in 10s" )
                self.time_pick_show = datetime.now() + timedelta( seconds = 10 )

    ## search data for weights, either as value or as weight key of sub data use them to randomly pick a result from the available ones
    def weighted_pick( self, data:dict ):
        if data:
            if len( data ) == 1:
                return next(iter(data))
            
            sum_wt = 0
            accum = 0

            for k, v in data.items():
                if isinstance( v, dict ):
                    if 'weight' in v:
                        ## if any element is labelled test we pick this one, if more than one will pick first
                        if isinstance( v['weight'], str ) and v['weight'] == "test":
                            return k
                        elif isinstance( v['weight'], int ):
                            sum_wt += v['weight']
                    else:
                        #debug( "weight not found, using default" )
                        data[k]['weight'] = 50
                        sum_wt += 50

                elif isinstance( v, int ):
                    sum_wt += v
                ## if any element is labelled test we pick this one, if more than one will pick first
                elif isinstance( v, str ) and v == "test":
                    return k
                elif not v:
                    sum_wt += 50
                    data[k] = 50

            choice = random.randrange(0, sum_wt)

            for l in data:
                value = data[l]
                if isinstance( value, dict ):
                    accum += value['weight']
                elif isinstance( value, int ):
                    accum += value

                if choice <= accum:
                    return l
        else:
            log.error( f"weighted_pick({data}) - no data passed!" )
        
        log.error( "weighted_pick() not returning data!")
        return ""

    def merge_wled_data( self, src, dest ):
        src_segs = len( src['seg'] )
        dest_segs = len( dest['seg'] )

        ## loop through destination.  If we have more destination segments, duplicate source, if less truncate:
        for i in range(dest_segs):
            dest['seg'][i].update( src['seg'][i%src_segs] )

    def pick_show( self ):
        ## clear data out...
        
        for role in self.config['hosts']:
            self.init_wled_data( role )
        
        if self.show in self.config['shows']:
            looks = self.config['shows'][self.show]

            # weighted pick for look:
            self.show_look = self.weighted_pick( looks )

            #debug( f"{self.show_look=}" )

            if not self.show_look:
                log.error( f"weighed_pick(show={self.show}) returned None" )
                return False
            
            if 'duration' in looks[self.show_look]:
                self.show_duration = timedelta( seconds=looks[self.show_look]['duration'] )
                #debug( f"{self.show_duration=}" )
            else:
                log.error( f"duration not in config.shows.{self.show}.{self.show_look}! using 60s..." )
                self.show_duration = timedelta( seconds=60 )
            
            if self.show_look in self.config['looks']:
                look = self.config['looks'][self.show_look]


                # loop through all roles
                for role in self.config['hosts']:
                    debug( f"{role=}:----")
                    effect_picked = False
                    scheme_picked = False
                    scheme = ""

                    # check if this role is in this look, otherwise pull from default looks
                    if role in look:
                        role_data = look[role]
                    elif role in self.config['looks']['default']:
                        role_data = self.config['looks']['default'][role]
                    else:
                        log.warning( f"role {role} has no default playlist." )
                        continue

                    # pick effect:
                    effect = self.weighted_pick( role_data['effects'] )

                    if effect == '$default':
                        if role in self.config['looks']['default']:
                            effect = self.weighted_pick( self.config['looks']['default'][role]['effects'] )
                            role_data = self.config['looks']['default'][role]
                        else:
                            log.error( f"pick_effect - '$default' tag but no default for role {role}")

                    elif effect[0] == '$' and effect[1:] in self.last_pick:
                        ## role matching, pull ALL data from dict and continue:
                        rl = effect[1:]
                        debug( f"{role}-effect: {effect} ")
                        if self.last_pick[rl]['effect_data']:
                            self.merge_wled_data( self.last_pick[rl]['effect_data'], self.wled_data[role] )
                            self.last_pick[role]['effect_data'] = copy.deepcopy( self.last_pick[rl]['effect_data'] )
                        else:
                            log.error( f"{role}-effect:{effect} - last_pick['effect_data'] is null" )
                            ## pick something from default here
                        
                        if self.last_pick[rl]['scheme_data']:
                            self.merge_wled_data( self.last_pick[rl]['scheme_data'], self.wled_data[role] )
                            self.last_pick[role]['scheme_data'] = copy.deepcopy(self.last_pick[rl]['scheme_data'])
                        else:
                            log.error( f"{role}-effect:{effect} - last_pick['scheme_data'] is null" )
                            ## pick something from default here

                        effect_picked = True
                        scheme_picked = True
                        scheme = effect


                    self.last_pick[role]['effect'] = effect
                    debug( f"{effect=}" )

                    if not effect_picked:
                        effects = self.config['effects']

                        if effect in effects:
                            effect_data = self.parse_effect( effect, role )
                            if effect_data:
                                self.merge_wled_data( effect_data , self.wled_data[role] )
                                self.last_pick[role]['effect_data'] = copy.deepcopy( effect_data )
                            else:
                                log.error( f"parse_effect({effect}) - returned None!" )
                        else:
                            log.error( f"{effect} not in config.effects!" )

                        scheme = self.weighted_pick( role_data['effects'][effect]['schemes'] )

                        if scheme.find( "$list" ) == 0:
                            list_name = scheme.strip()[6:-1]
                            if list_name in self.config['lists']['schemes']:
                                scheme = self.weighted_pick( self.config['lists']['schemes'][list_name] )
                            else:
                                log.error( "pick_scheme - list {list_name} not in lists.schemes" )
                                ## do we loop, or remove this from config??? idk
                        elif scheme[0] == '$' and scheme[1:] in self.last_pick:
                            ## role matching, pull data from dict:
                            # scheme = self.last_pick[scheme[1:]]['scheme']
                            if self.last_pick[scheme[1:]]['scheme_data']:
                                self.merge_wled_data( self.last_pick[scheme[1:]]['scheme_data'], self.wled_data[role] )
                                self.last_pick[role]['scheme_data'] = copy.deepcopy(self.last_pick[scheme[1:]]['scheme_data'])
                            else:
                                log.error( f"{role}-scheme:{scheme} - last_pick['scheme_data'] is null" )
                            
                            scheme_picked = True

                    self.last_pick[role]['scheme'] = scheme
                    debug( f"{scheme=}" )

                    if not scheme_picked:
                        scheme_data = self.parse_scheme( scheme )

                        if scheme_data:
                            self.merge_wled_data( scheme_data, self.wled_data[role] )
                            self.last_pick[role]['scheme_data'] = copy.deepcopy(scheme_data)
                        else:
                            log.error( f"scheme '{scheme}' returned None")

                    debug( f"{role}: {self.last_pick[role]}" )

                    #debug( f"self.wled_data[{role}] = {self.wled_data[role]}")

            else:
                log.error( f"{self.show_look} not in config.looks!" )
                return False
        else:
            log.error( f"{self.show} not in config.shows!" )
            return False
            
        return True

    # def ha_pull_config_now( self ):
    #     self.ha_pull_config = True

    # def ha_pick_show_now( self ):
    #     self.ha_pick_show = True

    def init_wled_data( self, role ):
        ## do this here every round.
        self.last_random[role] = dict()

        self.wled_data[role] = { 'seg': [] }

        c_role = self.config['hosts'][role]

        for i in range( c_role['data']['segments'] ):
            self.wled_data[role]['seg'].append( { "pal": 0, "col": [[0,0,0],[0,0,0],[0,0,0]], "grp": 1, "spc": 0 } )
        
    def __init__( self ):
        self.pull_config( )

        # self.ha_pull_config = False
        # self.ha_pick_show = False

        # setup the data registers for all roles of wled
        self.wleds = dict()

        self.last_random = dict()

        ## init data...
        for role in self.config['hosts']:
            max_seg = 0
            for h in self.config['hosts'][role].values():
                max_seg = max( max_seg, h['segments'] )

            self.config['hosts'][role]['data'] = { "segments": max_seg }

            log.warning( f"__init__: config.hosts.{role}.max_segments = {max_seg}" )

            self.init_wled_data( role )

            self.last_pick[role] = { 'effect': "", 'effect_data': {}, 'scheme': "", 'scheme_data': {} }


        self.time_pick_show     = datetime.now()

        self.show_duration      = timedelta( seconds= 5 )
        self.show_look          = ""
        self.show               = "off"

